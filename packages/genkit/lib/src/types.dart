// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by tool/schema_generator/bin/generate.dart.
// Do not edit this file manually.

import 'package:schemantic/schemantic.dart';
part 'types.schema.g.dart';

@Schematic()
abstract class CandidateSchema {
  double get index;
  MessageSchema get message;
  GenerationUsageSchema? get usage;
  FinishReason get finishReason;
  String? get finishMessage;
  Map<String, dynamic>? get custom;
}

@Schematic()
abstract class MessageSchema {
  Role get role;
  List<PartSchema> get content;
  Map<String, dynamic>? get metadata;
}

@Schematic()
abstract class ToolDefinitionSchema {
  String get name;
  String get description;
  dynamic get inputSchema;
  dynamic get outputSchema;
  Map<String, dynamic>? get metadata;
}

@Schematic()
abstract class PartSchema {}

@Schematic()
abstract class TextPartSchema implements PartSchema {
  String get text;
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic>? get custom;
}

@Schematic()
abstract class MediaPartSchema implements PartSchema {
  MediaSchema get media;
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic>? get custom;
}

@Schematic()
abstract class ToolRequestPartSchema implements PartSchema {
  ToolRequestSchema get toolRequest;
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic>? get custom;
}

@Schematic()
abstract class ToolResponsePartSchema implements PartSchema {
  ToolResponseSchema get toolResponse;
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic>? get custom;
}

@Schematic()
abstract class DataPartSchema implements PartSchema {
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic>? get custom;
}

@Schematic()
abstract class CustomPartSchema implements PartSchema {
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic> get custom;
}

@Schematic()
abstract class ReasoningPartSchema implements PartSchema {
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic>? get custom;
  String get reasoning;
}

@Schematic()
abstract class ResourcePartSchema implements PartSchema {
  Map<String, dynamic>? get data;
  Map<String, dynamic>? get metadata;
  Map<String, dynamic>? get custom;
  Map<String, dynamic> get resource;
}

@Schematic()
abstract class MediaSchema {
  String? get contentType;
  String get url;
}

@Schematic()
abstract class ToolRequestSchema {
  String? get ref;
  String get name;
  Map<String, dynamic>? get input;
  bool? get partial;
}

@Schematic()
abstract class ToolResponseSchema {
  String? get ref;
  String get name;
  dynamic get output;
  List<dynamic>? get content;
}

@Schematic()
abstract class ModelRequestSchema {
  List<MessageSchema> get messages;
  Map<String, dynamic>? get config;
  List<ToolDefinitionSchema>? get tools;
  String? get toolChoice;
  OutputConfigSchema? get output;
  List<DocumentDataSchema>? get docs;
}

@Schematic()
abstract class ModelResponseSchema {
  MessageSchema? get message;
  FinishReason get finishReason;
  String? get finishMessage;
  double? get latencyMs;
  GenerationUsageSchema? get usage;
  Map<String, dynamic>? get custom;
  Map<String, dynamic>? get raw;
  GenerateRequestSchema? get request;
  OperationSchema? get operation;
}

@Schematic()
abstract class ModelResponseChunkSchema {
  Role? get role;
  double? get index;
  List<PartSchema> get content;
  Map<String, dynamic>? get custom;
  bool? get aggregated;
}

@Schematic()
abstract class GenerateRequestSchema {
  List<MessageSchema> get messages;
  Map<String, dynamic>? get config;
  List<ToolDefinitionSchema>? get tools;
  String? get toolChoice;
  OutputConfigSchema? get output;
  List<DocumentDataSchema>? get docs;
  double? get candidates;
}

@Schematic()
abstract class GenerationUsageSchema {
  double? get inputTokens;
  double? get outputTokens;
  double? get totalTokens;
  double? get inputCharacters;
  double? get outputCharacters;
  double? get inputImages;
  double? get outputImages;
  double? get inputVideos;
  double? get outputVideos;
  double? get inputAudioFiles;
  double? get outputAudioFiles;
  Map<String, dynamic>? get custom;
  double? get thoughtsTokens;
  double? get cachedContentTokens;
}

@Schematic()
abstract class OperationSchema {
  String? get action;
  String get id;
  bool? get done;
  Map<String, dynamic>? get output;
  Map<String, dynamic>? get error;
  Map<String, dynamic>? get metadata;
}

@Schematic()
abstract class OutputConfigSchema {
  String? get format;
  Map<String, dynamic>? get schema;
  bool? get constrained;
  String? get contentType;
}

extension type FinishReason(String value) {
  static FinishReason get stop => FinishReason('stop');
  static FinishReason get length => FinishReason('length');
  static FinishReason get blocked => FinishReason('blocked');
  static FinishReason get interrupted => FinishReason('interrupted');
  static FinishReason get other => FinishReason('other');
  static FinishReason get unknown => FinishReason('unknown');
}
extension type Role(String value) {
  static Role get system => Role('system');
  static Role get user => Role('user');
  static Role get model => Role('model');
  static Role get tool => Role('tool');
}

@Schematic()
abstract class DocumentDataSchema {
  List<PartSchema> get content;
  Map<String, dynamic>? get metadata;
}

@Schematic()
abstract class GenerateActionOptionsSchema {
  String? get model;
  List<DocumentDataSchema>? get docs;
  List<MessageSchema> get messages;
  List<String>? get tools;
  String? get toolChoice;
  Map<String, dynamic>? get config;
  GenerateActionOutputConfigSchema? get output;
  Map<String, dynamic>? get resume;
  bool? get returnToolRequests;
  int? get maxTurns;
  String? get stepName;
}

@Schematic()
abstract class GenerateActionOutputConfigSchema {
  String? get format;
  String? get contentType;
  bool? get instructions;
  Map<String, dynamic>? get jsonSchema;
  bool? get constrained;
}
