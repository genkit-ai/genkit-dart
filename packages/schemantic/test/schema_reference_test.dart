// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import 'package:build_test/build_test.dart';
import 'package:schemantic/src/schema_generator.dart';
import 'package:source_gen/source_gen.dart';
import 'package:test/test.dart';

void main() {
  group('Schema References', () {
    const schematicBuilderLib = r'''
class Schematic {
  const Schematic();
}
class Field {
  final String? name;
  final String? description;
  const Field({this.name, this.description});
}
class Schema {
  final String? type;
  final Map<String, Schema>? properties;
  final bool? additionalProperties;
  final Schema? items;
  final List<String>? required;
  
  const Schema({
    this.type,
    this.properties,
    this.additionalProperties,
    this.items,
    this.required,
  });

  const Schema.object({
    Map<String, Schema>? properties,
    bool? additionalProperties,
    List<String>? required,
  }) : this(type: 'object', properties: properties, additionalProperties: additionalProperties, required: required);

  const Schema.string() : this(type: 'string');
  const Schema.integer() : this(type: 'integer');
  const Schema.boolean() : this(type: 'boolean');
  const Schema.array({Schema? items}) : this(type: 'array', items: items);
  
  Map<String, dynamic> toJson() => {};
}
class SchemanticType<T> {
  const SchemanticType();
  T parse(Object? json) => throw UnimplementedError();
  // ignore: avoid_renaming_method_parameters
  Object? jsonSchema({bool useRefs = false}) => null;
  Object? get schemaMetadata => null;
}
class JsonSchemaMetadata {
  const JsonSchemaMetadata({
    required String name, 
    required Object definition, // Relaxed type for test
    List<dynamic> dependencies = const [],
  });
}
''';

    test('generates reference to local schema variable', () async {
      final builder = PartBuilder([SchemaGenerator()], '.schema.g.dart');

      await testBuilder(
        builder,
        {
          'schemantic|lib/schemantic.dart': schematicBuilderLib,
          'a|lib/a.dart': r'''
import 'package:schemantic/schemantic.dart';

part 'a.schema.g.dart';

@Schematic()
const Schema partialType = Schema.object(
  properties: {'id': Schema.string()},
);

@Schematic()
const Schema mainType = Schema.object(
  properties: {
    'part': partialType,
    'other': Schema.string(),
  },
);
''',
        },
        outputs: {
          'a|lib/a.schema.g.dart': decodedMatches(
            allOf(
              contains('PartialType? get part'),
              contains('dependencies: [partialTypeType]'),
            ),
          ),
        },
      );
    });

    test('generates reference via .jsonSchema() call', () async {
      final builder = PartBuilder([SchemaGenerator()], '.schema.g.dart');

      await testBuilder(
        builder,
        {
          'schemantic|lib/schemantic.dart': schematicBuilderLib,
          'a|lib/a.dart': r'''
import 'package:schemantic/schemantic.dart';

part 'a.schema.g.dart';

@Schematic()
const Schema partialType = Schema.object(
  properties: {'id': Schema.string()},
);

@Schematic()
const Schema mainType = Schema.object(
  properties: {
    // This is how one might refer to it if they don't have the Schema object directly
    // but the generated type (though here we simulate it via parser logic)
    // Actually our parser supports .jsonSchema() on simple identifier variables too if they resolve to SchemanticType
    'part': partialTypeType.jsonSchema(),
  },
);
// Mock generated type for "partialTypeType" to exist in scope?
// The AST parser will try to resolve `partialTypeType`. 
// Since it doesn't exist in source, this might fail unless we define it.
// BUT `partialTypeType` IS generated by this build step, so it might not be visible to analyzer in the same step easily?
// For the test, we can declare a dummy type.
const partialTypeType = SchemanticType<PartialType>();
class PartialType {}
''',
        },
        outputs: {
          'a|lib/a.schema.g.dart': decodedMatches(
            allOf(
              contains('PartialType? get part'),
              contains('dependencies: [partialTypeType]'),
            ),
          ),
        },
      );
    });
  });
}
